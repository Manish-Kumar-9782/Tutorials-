# This module contains MySql command and query related functions.

import pymysql as sql
import pymysql.err as pyerr
from MyExceptions import AlreadyExist, MisMatchSize, DuplicateEntryFound
from MyExceptions import DatabaseNotFound, DatabaseTableNotFound, NoPrimaryKey, RowValueError, ColumnValueError
from MyExceptions import OperatorError, IntegrityError


class PySQL:

    def __init__(self, host, user, password, database=None):
        """
        It will connect to a database located on the server
        host: host name where the database server is located.
        user: user name to login in the server
        password: password of the user for login
        database: specify a database name to use a particular database
        :return: it will return a cursorInstance to write script on the sql database

        # Note This module is written by using the pymysql module which uses the MySQL sever.
        """
        self.host = host
        self.user = user
        self.password = password
        self.database = database
        self.conditional_operators = ["=", ">", "<", ">=", "<=", "<>", "!=", "BETWEEN", "LIKE", "IN"]
        # Now we will connect to the database.
        self.connect = sql.connect(host=self.host, user=self.user, password=self.password, database=self.database)
        # after making connection to the server we will make our cursor.
        self.cursor = self.connect.cursor()  # creating a cursor instance to write sql scripts

    # 1.First of all we will make a function to create a database.
    def create_database(self, database_name=None, user=None, password=None, host=None, cursor=None):
        """
        :param database_name: Name of the new database
        :param user: name of the user to login into the server
        :param password: name of the user to login
        :param host: host name where database server is located
        :param cursor: a cursorinstace which is generated by the currently connected channel
        :return:
        """

        if self.is_Database_exists(database_name):
            raise AlreadyExist(database_name)

        if cursor is not None:
            # if cursor is already given then we will use the given cursor
            cursor.execute("CREATE DATABASE " + database_name + ";")
        else:
            # if cursor is not given then we need to make a cursor instance from a new or existing connection.
            if self.connect is not None:
                cursor = self.connect.cursor()
                cursor.execute("CREATE DATABASE " + database_name + ";")
            else:
                # if we are not connected to any server then we need to make a connection.
                cursor = self.get_cursor(host, user, password)
                self.create_database(database_name=database_name, cursor=cursor)

    # -------------------------------------------------------------------------------- #

    # Now after creating a new database we need to make table to insert some entries.
    def create_table(self, database_name=None, table_name=None, table_columns=None, table_columns_type=None,
                     primary_key=None, user=None, password=None, host=None, cursor=None):
        """
        :param database_name: Name of the database in which we want to create the table.
        :param table_name: Name of the table which is going to be created.
        :param table_columns: columns name with their type, it must be a list or tuple
        :param user: Name of the user to logging.
        :param table_columns_type: columns data types like int, char, float, boolean ect, see the MySql data type for
                                    more information.
        :param primary_key: a columns name assigned as the primary key for the table.
        :param password: User Password to logging
        :param host: Host name where the server is located.
        :param cursor: A cursor for currently connected server to write the sql script
        :return: It will return the cursor of currently connected server.
        """

        if self.is_table_exist(database_name, table_name):
            raise AlreadyExist(".".join([database_name, table_name]))

        # Now first we need a formatted script for sql command execution.
        script = self.create_table_script_format(table_name, table_columns, table_columns_type, primary_key)

        if cursor is not None:
            # if we have the cursor then we need to select the database.
            cursor.execute("USE " + database_name)
            cursor.execute(script)
        else:
            # if cursor is None then we need to create a new cursor
            if self.connect is not None:
                cursor = self.connect.cursor()
                self.create_table(database_name=database_name, table_name=table_name, cursor=cursor,
                                  table_columns=table_columns, table_columns_type=table_columns_type,
                                  primary_key=primary_key)
            else:
                # Now if we don't have the cursor and also don't have any connection then we need to make new
                # connection.
                cursor = self.get_cursor(host, user, password)
                self.create_table(database_name=database_name, table_name=table_name, cursor=cursor,
                                  table_columns=table_columns, table_columns_type=table_columns_type,
                                  primary_key=primary_key)

    # -------------------------------------------------------------------------------- #

    def insert_row(self, database_name=None, table_name=None, columns=None, values=None,
                   primary_key=True, primary_key_value=None, allow_duplicate=False):
        """
        :param database_name: a database name from which we want to select the table or select the data entries.
        :param table_name: a table in which we want to insert the row.
        :param columns:  a row contains the values those should have the columns pairs
        :param values: values to of the row by matching with the columns.
        :param primary_key: if primary_key is true then we use primary_key to check for duplicate values.
        :param primary_key_value: a primary_key value must be provided if parameter primary_key is set True.
        :param allow_duplicate: allow duplicate insertion of entries, Note: this will cause an duplicate insertion
                                we have any column as primary key in the table, so don't pass any table with this
                                which have Primary keys.
        :return: None
        """
        # now after creating the any table or in exciting we need to insert a new row.
        # Now to insert a row in any database we need to ensure the database name and the table in which we
        # want to insert the entry.
        try:
            if primary_key:
                _result = self.is_duplicate_present(database_name, table_name, columns, values,
                                                    primary_key=primary_key, primary_key_value=primary_key_value)
                if _result:
                    raise DuplicateEntryFound
                else:
                    self._insert(database_name, table_name, columns, values)

            else:
                if allow_duplicate:
                    # if we allow duplicate entries then just _insert a row
                    self._insert(database_name, table_name, columns, values)
                else:
                    # if we don't allow duplicate entries then first we need to check for the duplicate entries
                    # if found raise error duplicate found.
                    _result = self.is_duplicate_present(database_name, table_name, columns, values,
                                                        primary_key=primary_key, non_primary_key=True)
                    if _result:
                        self._insert(database_name, table_name, columns, values)
                    else:
                        raise DuplicateEntryFound

        except DuplicateEntryFound:
            raise DuplicateEntryFound(
                custom_message=f"Duplicate insertion detected of with PRIMARY KEY {primary_key_value}!")

    # -------------------------------------------------------------------------------- #

    def insert_column(self, database_name=None, table_name=None, column_name=None, column_type=None,
                      column_pos=None, Constraint=None):
        """
        Insert a column in a given table of a given database.
        :param database_name: Name of the database in which our table is placed.
        :param table_name: Name of the table in which we want to add a new column
        :param column_name: Name of the columns.
        :param column_type: column data type to specify the variable type of column in sql database.
        :param column_pos: position at which we want to insert a column into a table, by default it will be last column.
        :param Constraint: default value given to that column, by default it will accept the NULL values.
        :return: None
        """
        script = f"""ALTER TABLE {table_name}
                     ADD {column_name} {column_type} {Constraint}
                     {column_pos}"""
        if self.cursor is not None:
            try:
                if self.is_Database_exists(database_name):
                    if self.is_table_exist(database_name, table_name):
                        try:
                            self.cursor.execute(f"""USE {database_name}""")
                            self.cursor.execute(script)
                            self.connect.commit()
                        except pyerr.ProgrammingError:
                            print("There is something wrong with script")
                        except pyerr.DataError:
                            print("There is a problem to process the data.")
                        except pyerr.IntegrityError:
                            print("Please Check Entries values like primary key, foreign key etc.")
                    else:
                        raise DatabaseTableNotFound

                else:
                    raise DatabaseTableNotFound

            except DatabaseNotFound:
                raise DatabaseNotFound(database_name)
            except DatabaseTableNotFound:
                raise DatabaseTableNotFound(database_name, table_name)

        else:
            # if we don't have cursor then we need to make one.
            self.get_cursor()  # cursor will be assigned to the self.cursor
            self.insert_column(database_name, table_name, column_name, column_type,
                               column_pos, Constraint)

    # -------------------------------------------------------------------------------- #

    def delete_entry(self, database_name, table_name, where):
        """
        To delete an entry from a table which is placed in given database on sql server.
        :param database_name: Name of the database.
        :param table_name: Name of the table
        :param where: tuple, it is the condition by using we are going to find out the desired result, Note: use primary
                        key or unique id to get the single row for deletion or common id form multiple row deletion.
        :return: None
        """
        script = f"""DELETE FROM {table_name} WHERE {self.where_condition_format(where)}"""
        if self.cursor is not None:
            self.cursor.execute(f"USE {database_name}")
            self.cursor.execute(script)
            self.connect.commit()
        else:
            self.get_cursor()
            self.delete_entry(database_name, table_name, where)

    # -------------------------------------------------------------------------------- #

    def delete_column(self, database_name, table_name, column_name):
        """
        This method will be used to drop or delete a column from a sql database table.
        :param database_name: Name of the database in which our targeted table is located.
        :param table_name: table name in from which we want to remove the columns.
        :param column_name: Name of the column which is need to drop or delete.
        :return:None
        """
        script = f"""ALTER TABLE {table_name} DROP COLUMN {column_name}"""
        if self.cursor is not None:
            self.cursor.execute(f"USE {database_name}")  # selecting the given database
            self.cursor.execute(script)  # deleting the columns as given
            self.connect.commit()
        else:
            self.get_cursor()
            self.delete_entry(database_name, table_name, column_name)

    # -------------------------------------------------------------------------------- #

    def search_entry(self, database_name, table_name, primary_key=None, primary_key_value=None):
        """
        This method will return single record if found or return -1 if found duplicate.
        :param database_name: Name of the database in which our table is located.
        :param table_name: Name of the table in which we want to search our record.
        :param primary_key: A Unique in a selected column. Note: use primary key instead of using the where condition
                            to get the desired result.
        :param primary_key_value: value of the primary, if the value is present in the database then it will return a
                                of value corresponding to their columns and if value is not present in the database then
                                it will return -1
        :return: tuple if Entry is present or -1 if Entry is not present
        """

        if self.cursor is not None:
            if primary_key is not None:
                self.cursor.execute(f"""USE {database_name}""")
                # first we will get the primary key.
                self.cursor.execute(f"""show keys from {table_name} where key_name = 'PRIMARY'""")
                primary_id = self.cursor.fetchall()[0]
                # Now if Key_Name is PRIMARY in the primary id then we will get the record by given primary key value
                # Key Name is located at index num 2 and PRIMARY KEY COLUMN is located at index num 4.
                if primary_id[2] == 'PRIMARY' and primary_id[4] == primary_key:
                    # Note primary_id[4] contains the primary_key column name
                    # we have any primary key then we need to get the record by using primary key value.
                    self.cursor.execute(f"""SELECT * FROM {table_name}  WHERE {primary_key} = '{primary_key_value}'""")
                    result = self.cursor.fetchall()
                    if result:
                        return result[0]
                    else:
                        return -1

                else:
                    raise KeyError(
                        f"PRIMARY KEY Name is invalid, please specify a right primary key: given key '{primary_key}'")

            else:
                raise ValueError("PRIMARY KEY can't be None, you must specify the primary_key value.")

        else:
            # if we don't have the cursor then we need new one.
            self.get_cursor()
            self.search_entry(database_name, table_name, primary_key, primary_key_value)

    # -------------------------------------------------------------------------------- #

    def search_entries(self, database_name, table_name, where):
        """
        Search a record within a given condition specified by where variable.
        :param database_name: Name of the database in which our table is located.
        :param table_name: Name of the table_name in which our record are located.
        :param where: tuple, conditions to filter the record to get only required records.
        :return: tuple if found, -1 if not found.
        """
        if self.cursor is not None:
            if isinstance(where, tuple) or isinstance(where, list):
                # first select the database.
                self.cursor.execute(f"""USE {database_name}""")
                # filter the records by using the where condition.
                script = f"""select * from {table_name} where {self.where_condition_format(where)}"""
                self.cursor.execute(script)
                result = self.cursor.fetchall()

                if result:
                    return result
                else:
                    return -1
            else:
                raise TypeError("where must be type of 'tuple' or a 'list' containing a sequence of conditions.")
        else:
            self.get_cursor()
            self.search_entries(database_name, table_name, where)

    # -------------------------------------------------------------------------------- #

    def _insert(self, database_name, table_name, _columns, values):

        if database_name and table_name:
            # if both database and table name are defined then we need to get the columns and rows values.
            if self.cursor:
                if isinstance(_columns, (list, tuple)) and isinstance(values, (list, tuple)):
                    # if we already have a cursor then we need to insert the entry.
                    if self.is_Database_exists(database_name):  # test if database exist
                        if self.is_table_exist(database_name, table_name):  # test if table exist

                            self.cursor.execute(f"""USE {database_name}""")
                            self.cursor.execute(
                                f"""INSERT INTO {table_name} ({", ".join(_columns)}) VALUES ({self.get_formatted_values(values)});""")
                            self.connect.commit()
                        else:
                            raise DatabaseTableNotFound(database_name, table_name)
                    else:
                        raise DatabaseNotFound(database_name)
                else:
                    print("columns and values supposed to be strings")

    # -------------------------------------------------------------------------------- #

    def get_all_entries(self, database_name, table_name):
        """
        Get all the available record from the desired table located in given database.
        :param database_name: Name of the database in which our table is located.
        :param table_name: Name of the table in which our record is located.
        :return: tuple or records.
        """
        if self.cursor is not None:
            self.cursor.execute(f"USE {database_name}")
            self.cursor.execute(f"""select * from {table_name}""")
            return self.cursor.fetchall()
        else:
            self.get_cursor()
            self.get_all_entries(database_name, table_name)

    def get_columns(self, database_name, table_name):
        """
        Get all the columns name from a table which is located in a given database.
        :param database_name: Name of the database in which our table is located.
        :param table_name: Name of the table in which our record is located.
        :return: tuple
        """

        if self.cursor is not None:
            # first we need to fetch some data, since we don't need any data we will limit it to 0 to increase
            # efficiency.
            self.cursor.execute(f"USE {database_name}")
            self.cursor.execute(f"select * from {table_name} limit 0;")
            self.cursor.fetchall()
            columns = [row[0] for row in self.cursor.description]
            return columns

    def get_book_instance(self, database, table, key, value):
        """
        This method will return a book object containing all the information of book received from database.
        :return: Book Instance
        """
        result = self.search_entry(database, table, key, value)
        if result != -1:
            return Book(Id=result[0], Title=result[1], Author=result[2], Status=result[3], Name=None)
        else:
            return -1

    def is_Database_exists(self, Database):
        """
        Check the existence of the given Database on the MySQL sever.
        :param Database: Name of the database which need to be find out in the server.
        :return: True or False.
        """

        script = f""" SELECT IF(EXISTS(
                                SELECT * FROM INFORMATION_SCHEMA.SCHEMATA
                                WHERE SCHEMA_NAME = '{Database}'), True, False) as exist"""

        self.cursor.execute(script)
        result = self.cursor.fetchone()[0]

        if result:
            return True
        else:
            return False

    def is_table_exist(self, Database, table):
        """
        Check the existence of the given table in a given database on the MySQL server.
        :param Database: Name of the Database in which table is located.
        :param table: Name of the table to be find out.
        :return: True or False
        """

        script = f"""SELECT IF(EXISTS
                        (SELECT * FROM INFORMATION_SCHEMA.TABLES
                        WHERE
                        TABLE_SCHEMA = '{Database}'
                        AND
                        TABLE_NAME = '{table}'
                        ), True, False) as exist"""

        self.cursor.execute(script)
        result = self.cursor.fetchone()[0]
        if result:
            return True
        else:
            return False

    def get_primary_key(self, database: str, table: str):
        """
        Get Primary keys from a table located in given database.
        :param database: name of the database, string;
        :param table: name of the table in which our primary is located, string;
        :return: dict
        """
        if self.cursor is not None:
            # if database is exist
            if self.is_Database_exists(database):
                if self.is_table_exist(database, table):
                    self.cursor.execute(F"USE {database}")
                    self.cursor.execute(f"SHOW KEYS FROM {table} WHERE key_name = 'PRIMARY';")
                    columns = [col[0] for col in self.cursor.description]
                    row = self.cursor.fetchone()
                    if row:
                        result = {key: value for key, value in zip(columns, row)}
                        return result['Column_name']
                    else:
                        return -1
                else:
                    raise DatabaseTableNotFound(database, table)
            else:
                raise DatabaseNotFound(database)

    def get_primary_key_value(self, database: str, table: str):
        """
        Get all the value of primary key of a table which is located in given database.
        :param database: Database name in which our table is located.
        :param table: table name in which our primary key value ar place.
        :return: tuple
        """
        primary_key = None
        try:
            primary_key = self.get_primary_key(database, table)

            if self.cursor is not None:
                if primary_key:
                    self.cursor.execute(f"USE {database}")
                    self.cursor.execute(f"select {primary_key} from {table};")
                    values = self.cursor.fetchall()
                    return primary_key, tuple([val[0] for val in values])
                else:
                    raise NoPrimaryKey(database, table)
            else:
                self.get_cursor()
                self.get_primary_key_value(database, table)
        except DatabaseNotFound:
            print(f"Database {database} is not found")
        except DatabaseTableNotFound:
            print(f"Database table {table} is not found")

    # ============================================================================================================ #

    def is_duplicate_present(self, database, table, column=None, row=None, primary_key=True,
                             primary_key_value=None, non_primary_key=False):

        """
        A method to find duplicate values in the a table located in a given database of MySQL Server, it will return
        True if we found any match else False
        :param database: Name if the database in which our table is located.

        :param table: Table Name in which we want to find out duplicate entries.

        :param column: column values to filter out the database by using only those values. Not only use with
                        non primary key is True

        :param row: column values to filter out the database by using we will get selected entries. Not only use with
                        non primary key is True

        :param primary_key: A primary key value to filter the database by using with primary key.
        :param primary_key_value:  value for primary key.
        :param non_primary_key: boolean, by default is False: use primary key mode, if False then don't use primary key
                            else provide column and row values
        :return: True or False

        Note: if you set non_primary_key as True then we don't include Primary key column in column list.
        """
        if isinstance(primary_key, bool) or isinstance(non_primary_key, bool):

            if primary_key and non_primary_key:
                raise TypeError("Argument 'primary_key' and 'non_primary_key' can't be True at the same time!")

            elif not primary_key and not non_primary_key:
                raise TypeError("Argument 'primary_key' and 'non_primary_key' can't be  False at the same time!")

            # if we choose primary_key filter
            elif primary_key:
                # if primary_key is set true then we need to provide ethe primary key value
                if not primary_key_value:
                    raise ValueError("Primary key value is not given!")

                _primary_key, _key_value = self.get_primary_key_value(database, table)
                if primary_key_value in _key_value:
                    return True
                else:
                    return False

            # if we choose non primary key filter.
            elif non_primary_key:
                _columns = self.get_columns(database, table)
                pkey = self.get_primary_key(database, table)
                if pkey != -1:
                    _columns.remove(pkey)
                # getting the length of given column, columns from table and row values
                col_len = len(column)  # length of given columns
                row_len = len(row)  # length of row values
                _col_len = len(_columns)  # length of columns from table

                if col_len != row_len:
                    raise MisMatchSize(
                        custom_message=f"Given column and row size have to be same given shape ({col_len},{row_len})!")

                if _col_len == col_len:
                    if all([True if name2 in _columns else False for name1, name2 in zip(_columns, column)]):
                        # if all column Names found in the given table then we will find duplicate
                        _mapped = self._map_colrow_values(column, row)
                        # Now we will map our _mapped values with operators
                        _conditions = self._map_where_operators(_mapped, "=")

                        return self.search_entries(database, table, where=_conditions)
                    else:
                        miscolumns = [True if name2 in _columns else False for name1, name2 in zip(_columns, column)]

                        for _bool, _value in zip(miscolumns, column):
                            if not _bool:
                                raise ColumnValueError(message=f"No Column '{_value}' found  in '{database}.{table}'!")

                else:
                    raise MisMatchSize(
                        custom_message=f"Given Column size do not match to '{database}.{table}' column size!")

        else:
            if not isinstance(primary_key, bool):
                raise TypeError("argument 'primary_key' -> should be a boolean value")
            elif not isinstance(non_primary_key, bool):
                raise TypeError("argument 'non_primary_key' -> should be a boolean value")

    def _check_duplicate_primary_values(self, database, table, columns, values, primary_key):
        """
        This method will return if we found on or more duplicate in the database else it will return False.
        :return: True or False
        """
        try:
            map_values = self._map_colrow_values(columns, values)  # test if
            if map_values:
                # if we have any pair of row column values then we need to find the primary key duplication error
                primary_key, key_values = self.get_primary_key_value(database, table)
                cols = self.get_columns(database, table)
                new_map = {key: val for key, val in zip(cols, values)}
                if new_map[primary_key] in key_values:
                    raise DuplicateEntryFound

        except MisMatchSize:
            raise MisMatchSize(custom_message="Size of Column does not match to size of row!")
        except DuplicateEntryFound:
            raise DuplicateEntryFound(
                custom_message=f"Duplicate insertion detected of {new_map[primary_key]} with PRIMARY KEY {primary_key}!")

    @staticmethod
    def _map_colrow_values(col, row):
        """
        Map given values with their corresponding order. if length of col and row values are not match then it will
        raise mismatch of length.
        :param col: a list or tuple of values.
        :param row: a list or tuple of values.
        :return: dict of mapped values.
        """
        if col is None and row is None:
            # if both col and row are empty then we will raise this error
            raise ValueError("row and column both are empty! can't accept the empty data package")

        elif col is None or len(col) == 0:
            ncol = [i for i in range(1, len(row) + 1)]  # if we don't have columns then we will give column by numbers
            new_col = [f"_col{i}_" for i in ncol]
            return {key: value for key, value in zip(new_col, row)}

        elif row is None or len(row) == 0:
            raise RowValueError("Can't Accept an empty row, please provide row values!")

        elif len(row) > len(col):
            col_len = len(col)
            raise ColumnValueError(message=f"Undefined Column Name for value '{row[col_len]}'!")

        elif len(row) < len(col):
            return {key: value for key, value in zip(col, row)}

        elif len(col) == len(row):
            return {key: value for key, value in zip(col, row)}
        else:
            raise Exception("Unknown Error raised, unable to map row and col values!")

    def get_cursor(self, host=None, user=None, password=None):
        """
        this function is mainly used to create a cursor for writing the script on the sql database.
        :param host: hostname at which the server is located.
        :param user: user name to logging.
        :param password: user password to logging.
        :return: This function will return a cursor instance.
        """

        # now if we don't have any cursor then we will make a new cursor by making a new cursor instance.
        if self.connect is not None:
            # if we have a connection then we don't need to make a new connection.
            return self.connect.cursor()
        else:
            # if we don't have a connection then we have to make a new connection.
            # in this situation we need host, user and password values.
            if user is None:
                user = self.user

            if password is None:
                password = self.password

            if host is None:
                host = self.host

            self.connect = sql.connect(host=host, user=user, password=password)
            self.cursor = self.connect.cursor()
            return self.cursor

    @staticmethod
    def create_table_script_format(table_name=None, table_columns=None,
                                   table_columns_type=None, primary_key=None):
        """
        This function is mainly used to make a script command for creating a table with the following
        given parameters.
        :param table_name: name of the table.
        :param table_columns: name of the columns, it must be a list or tuple.
        :param table_columns_type: type of the columns data it must be a list or tuple in their corresponding order.
                                Note: types must be defined in uppercase strings.
        :param primary_key: primary key column name to assign the primary key for the given table.
        :return: It will return string.
        """
        script = f"CREATE TABLE {table_name} ("
        if isinstance(table_columns, list) or isinstance(table_columns, tuple):
            if isinstance(table_columns_type, list) or isinstance(table_columns_type, tuple):

                for col, tpy in zip(table_columns, table_columns_type):
                    if isinstance(col, str) and isinstance(tpy, str):
                        # if we get the string then only we will go to next statement.
                        script += col + " " + tpy.upper() + ', '
                    else:
                        raise ValueError("Values supposed to type of string!")

                if primary_key is not None:
                    script += f"PRIMARY KEY ({primary_key}));"
                else:
                    script = script.rstrip(", ")
                    script += ");"

        return script

    def where_condition_format(self, where):
        """
        This function will be used to verify the where clause condition according to the sql formatting.
        :param where: condition to filter out the database.
        :return: string, a part of MySQL script which is placed in where clause.
        """

        # these are the following operators which are used on where clause.
        # Now we need to check our where clauses, it will be a single string or tuple or list of string
        # following where clause formatted condition we use need to make it verify.
        # we need to verify the left and right operands and operator.

        # Now we will make a another function here to make our work easy.
        def _where_(Where):
            """
            This function will check the syntax for each where, in this where is string not a list or tuple
            :param Where: this is the single string nor a tuple or  the list so we can focus on the syntax only
            :return:
            """
            left_op = None
            right_op = None
            ops_pos = -1  # by default we don't find any operator in the where clause.
            ops = None
            """
            :param left_op: this will have the left operand.
            :param ops_pos: this will have the operator position, if it contains -1 that menas we have syntax error
            :param right_op: this will have the right operator,
            """

            for ops in self.conditional_operators:
                if ops in Where:
                    ops_pos = Where.find(ops)
                    left_op = Where[:ops_pos]
                    right_op = Where[len(ops) + ops_pos + 1:]
                    ops = Where[ops_pos:ops_pos + len(ops)]
                    break

            # now we need to check our values.
            if ops_pos != -1:

                if len(left_op.strip()) != 0 and len(right_op.strip()) != 0:
                    if right_op.find("'") != -1:
                        return f"""{left_op.strip()} {ops.strip()} {right_op.strip()} """
                    else:
                        return f"""{left_op.strip()} {ops.strip()} '{right_op.strip()}' """
                else:
                    raise SyntaxError("Where clause syntax error, operands are not defined")

            else:
                raise SyntaxError(
                    f"""Where clause syntax error, couldn't found any relational operator in "{Where}" """)

        if isinstance(where, str):
            return _where_(where)

        elif isinstance(where, tuple) or isinstance(where, list):
            strs = []
            for wh in where:
                strs.append(_where_(wh))
            return " AND ".join(strs)

    def _map_where_operators(self, operands, to_all=None, op_seq=None):
        """
        A function to map conditional operators in between the two operands which is provided by params parameter.
        :param operands: dict or list or tuple containing the operands, which needed to map with given operators or
                        operators in sequence with their corresponding order.
        :param to_all: an operator to apply on all pairs of operands.
        :param op_seq: a sequence to apply in operator in their corresponding order.
        :return: tuple
        """
        _mapped_operands = []
        _op_bool = None

        if op_seq:
            _op_bool = [True if op in self.conditional_operators else False for op in op_seq]

        # ---------------------------------------#
        # if by mistake both op_sq and to_all defined then we need to raise error
        if op_seq and to_all:
            raise ValueError(f"argument 'to_all' and 'op_seq' both can't be true at the same time!")

        # ---------------------------------------#
        # if both op_seq and to_all are not defined then we need to raise error
        if not op_seq and not to_all:
            raise ValueError(f"We don't have any operator to map with operands!")

        # ---------------------------------------#
        # first we will check the the given operators.

        if op_seq and not all(_op_bool):
            # if any operator not found in defined operator then we will raise Error
            raise OperatorError(message=f"Operator '{op_seq[_op_bool.index(False)]}' is not defined!")

        # ---------------------------------------#
        if not operands:
            raise ValueError("we don't have any pair of operands to process, please provide a pair of operand!")
        else:
            if isinstance(operands, (list, tuple, dict)):
                if isinstance(operands, dict):
                    operands = operands.items()
            else:
                raise TypeError("argument 'operands' must be list or tuple or dict!")

        # ---------------------------------------#
        # if only op_seq is given
        if op_seq and not to_all:
            # if we only have ope_seq only
            if len(op_seq) != len(operands):
                raise MisMatchSize(custom_message=f"The length of 'op_seq' does not match to length of 'operands'!")

            for pair, op in zip(operands, op_seq):
                l_op, r_op = pair
                _mapped_operands.append(f"{l_op} {op} '{r_op}'")
            return _mapped_operands

        # ---------------------------------------#
        # if only to_all is given
        if to_all and not op_seq:
            for l_op, r_op in operands:
                _mapped_operands.append(f"{l_op} {to_all} '{r_op}'")
            return _mapped_operands

    def get_formatted_values(self, values):
        """
        Transform the values into a sql server script.
        :param values: values to be add in the script
        :return: string;
        """
        script = ""
        for value in values:
            script += f"'{value}', "
        script = script.strip()

        if script[-1] == ',':
            script = script[0:-1]

        return script

    def del_cursor(self):
        """
        Delete the cursor and close the and close the connection.
        :return: None
        """
        self.cursor = None
        self.connect.close()


# We will make another class to hold the Books information.

class Book:

    def __init__(self, Id, Name, Title, Author, Status=None, Pages=None, Publisher=None, Language=None):
        """
        A constructor to initiate the book object with containing its infomation.
        :param Id: Book id which is unique.
        :param Name: Name of the book
        :param Title: Title of the book.
        :param Author: Writer of the book
        :param Status: Status that a books is Available.
        :param Pages: Total pages in book
        :param Publisher: Publisher of the book.
        :param language: Language in which book is written
        """

        self.id = Id
        self.name = Name
        self.title = Title
        self.author = Author
        self.status = Status
        self.pages = Pages
        self.publisher = Publisher
        self.language = Language

    @staticmethod
    def get_keys():
        return ['Id', 'Name', 'Title', 'Author', 'Status', 'Pages', 'Publisher', 'Language']

    def get_values(self):
        return [self.id, self.name, self.title, self.author, self.status, self.pages, self.publisher, self.language]

    def get_dict(self):
        return {key: value for key, value in zip(self.get_keys(), self.get_values())}


if __name__ == "__main__":
    # testing the module
    sqlcur = PySQL('localhost', 'root', 'ManishKumar@9782')

    columns = ("BOOK_TITLE", "BOOK_AUTHOR", "BOOK_STATUS")
    row = ("Harry Potter", "JK Rollance", "Availabel")
    operands = sqlcur._map_colrow_values(columns, row)

    # result = sqlcur.is_duplicate_present('libdata', 'books', columns, row, primary_key=False, non_primary_key=True)
    result = sqlcur.create_table_script_format('issued',
                                      ("BOOK_ID", "ISSUED_TO", "DATE_TIME"),
                                      ("INT NOT NULL AUTO_INCREMENT",
                                       "VARCHAR(200) NOT NULL, "
                                       "TIMESTAMP"))
    print()
